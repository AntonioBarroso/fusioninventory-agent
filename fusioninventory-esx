#!/usr/bin/perl
use Data::Dumper;

use strict;
use warnings;

package VMware::PoorBoySOAP;
use Data::Dumper;

use XML::TreePP;
use LWP::UserAgent;
use HTTP::Cookies; #for testing

sub new {
    my (undef, $params) = @_;

    my $self = {
        ua => LWP::UserAgent->new(),
        url => $params->{url}
    };
    my $cookie = new HTTP::Cookies( ignore_discard => 1 );
    $self->{ua}->cookie_jar( $cookie );

    push @{ $self->{ua}->requests_redirectable }, 'POST';
    $self->{ua}->agent("VMware::PoorBoySOAP/0.1 ");

    $self->{tpp} = XML::TreePP->new(force_array => [qw( returnval propSet )]);
    return bless $self;
}

sub _send {
    my ($self, $action, $xmlToSend) = @_;


    my $req = HTTP::Request->new(POST => $self->{url});
    $req->content($xmlToSend);
    $req->{_headers}->{soapaction} = "\"urn:vim25#".$action."\"";
    $req->{_headers}->{accept} = ['text/xml', 'application/soap' ];
    $req->{_headers}->{'content-length'} = length($xmlToSend);
    $req->{_protocol} = 'HTTP/1.1';
    $req->content_type('text/xml; charset=utf-8');

    my $res = $self->{ua}->request($req);

    if ($res->is_success) {
        return $res->content;
    } else {
        return;
    }
}

sub _parseAnswer {
    my ($self, $answer) = @_;

    return unless $answer;
    undef $/;

# We simplify the XML structure
    my $pattern = '.*<\w+Response xmlns="urn:vim25">(.+)</\w+Response>.*$';
    $answer =~ s/$pattern/$1/sg,;
    $answer =~ s/ (xsi:|)type="[:\w]+"//sg;
    my $tmpRef = $self->{tpp}->parse($answer);

# Login
    if ($tmpRef->{returnval}[0] && !$tmpRef->{returnval}[0]{propSet}) {
        return $tmpRef->{returnval}[0];
    }
# Else the rest

    my $ref = [];
    foreach (@{$tmpRef->{returnval}}) {
        if ($_->{propSet}) {
            my %tmp;
            foreach my $p (@{$_->{propSet}}) {
                next unless $p->{val};
                $tmp{$p->{name}} = $p->{val}
            }
            push @$ref, \%tmp;
        } else {
            push @$ref, $_;
        }
    }

    return $ref;

}

sub login {
    my ($self, $login, $pw) = @_;

    my $req =
        '<?xml version="1.0" encoding="UTF-8"?>
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <soapenv:Body>
        <Login xmlns="urn:vim25"><_this type="SessionManager">ha-sessionmgr</_this>
        <userName>%s</userName><password>%s</password></Login></soapenv:Body></soapenv:Envelope>';

    my $answer = $self->_send('Login', sprintf($req, $login, $pw));
    return $self->_parseAnswer($answer);

}

sub getHostInfo {
    my ($self) = @_;


    my $req =
        '<?xml version="1.0" encoding="UTF-8"?><soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"><soap:Body><RetrieveServiceContent xmlns="urn:vim25"><_this type="ServiceInstance">ServiceInstance</_this></RetrieveServiceContent></soap:Body></soap:Envelope>';


    my $answer = $self->_send('RetrieveServiceContent', $req);
    my $ref = $self->_parseAnswer($answer);
    return $ref;
}


sub getVirtualMachineList {
    my ($self) = @_;

    my $req =

        '<?xml version="1.0" encoding="UTF-8"?>
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <soapenv:Body>
        <RetrieveProperties xmlns="urn:vim25"><_this type="PropertyCollector">ha-property-collector</_this>
        <specSet><propSet><type>VirtualMachine</type><all>0</all></propSet><objectSet><obj type="Folder">ha-folder-root</obj>
        <skip>0</skip><selectSet xsi:type="TraversalSpec"><name>folderTraversalSpec</name><type>Folder</type><path>childEntity</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet><selectSet><name>datacenterHostTraversalSpec</name></selectSet><selectSet><name>datacenterVmTraversalSpec</name></selectSet><selectSet><name>datacenterDatastoreTraversalSpec</name></selectSet><selectSet><name>datacenterNetworkTraversalSpec</name></selectSet><selectSet><name>computeResourceRpTraversalSpec</name></selectSet><selectSet><name>computeResourceHostTraversalSpec</name></selectSet><selectSet><name>hostVmTraversalSpec</name></selectSet><selectSet><name>resourcePoolVmTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>datacenterDatastoreTraversalSpec</name><type>Datacenter</type><path>datastoreFolder</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>datacenterNetworkTraversalSpec</name><type>Datacenter</type><path>networkFolder</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>datacenterVmTraversalSpec</name><type>Datacenter</type><path>vmFolder</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>datacenterHostTraversalSpec</name><type>Datacenter</type><path>hostFolder</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>computeResourceHostTraversalSpec</name><type>ComputeResource</type><path>host</path><skip>0</skip></selectSet><selectSet xsi:type="TraversalSpec"><name>computeResourceRpTraversalSpec</name><type>ComputeResource</type><path>resourcePool</path><skip>0</skip><selectSet><name>resourcePoolTraversalSpec</name></selectSet><selectSet><name>resourcePoolVmTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>resourcePoolTraversalSpec</name><type>ResourcePool</type><path>resourcePool</path><skip>0</skip><selectSet><name>resourcePoolTraversalSpec</name></selectSet><selectSet><name>resourcePoolVmTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>hostVmTraversalSpec</name><type>HostSystem</type><path>vm</path><skip>0</skip><selectSet><name>folderTraversalSpec</name></selectSet></selectSet><selectSet xsi:type="TraversalSpec"><name>resourcePoolVmTraversalSpec</name><type>ResourcePool</type><path>vm</path><skip>0</skip></selectSet></objectSet></specSet></RetrieveProperties></soapenv:Body></soapenv:Envelope>
        ';


    my $answer = $self->_send('RetrieveProperties', $req);
    my $ref = $self->_parseAnswer($answer);
    my @list;
    if (ref($ref) eq 'HASH') {
        push @list, $ref;
    } else {
        @list = @{$ref};
    }

    my @ids;
    foreach (@list) {
        push @ids, $_->{obj};
    }

    return \@ids;

}

sub getVirtualMachineById {
    my ($self, $id) = @_;

    my $req = '<?xml version="1.0" encoding="UTF-8"?>
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <soapenv:Body>
        <RetrieveProperties xmlns="urn:vim25"><_this type="PropertyCollector">ha-property-collector</_this>
        <specSet><propSet><type>VirtualMachine</type><all>1</all></propSet><objectSet><obj type="VirtualMachine">%d</obj>
        </objectSet></specSet></RetrieveProperties></soapenv:Body></soapenv:Envelope>
        ';

    my $answer = $self->_send('RetrieveProperties', sprintf($req, $id));
    my $ref = $self->_parseAnswer($answer);

    return $ref;
}

sub getHostFullInfo {
    my ($self, $id) = @_;

    my $req = '<?xml version="1.0" encoding="UTF-8"?>
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <soapenv:Body>
        <RetrieveProperties xmlns="urn:vim25"><_this type="PropertyCollector">ha-property-collector</_this>
        <specSet><propSet><type>HostSystem</type><all>1</all></propSet><objectSet><obj type="HostSystem">ha-host</obj>
        </objectSet></specSet></RetrieveProperties></soapenv:Body></soapenv:Envelope>
        ';

    my $answer = $self->_send('RetrieveProperties', sprintf($req, $id));
    my $ref = $self->_parseAnswer($answer);

    return $ref;
}


1;

use lib '/home/goneri/fusioninventory/agent/lib';
use FusionInventory::Agent::XML::Query::Inventory;
use FusionInventory::Agent::Tools;
use FusionInventory::Agent::Config;
use FusionInventory::Logger;

use Getopt::Long;

my $args = {};

GetOptions(
        $args, 'host=s', 'user=s', 'password=s', 'directory=s'
        );

usage() unless $args->{host} and $args->{user} and $args->{password} and $args->{directory};

sub usage {

    print STDERR <<EOF;

    A command line tool to create .ocs file from an ESX server.

        USAGE:
        --host hostname        : hostname is the hostname of the IP address of the ESX server 
        --user username        : the ESX user name
        --password xxxx        : the ESX password 
        --directory /somewhere : the location where the .ocs file must be written

        EXAMPLE:
        $0 --host myesx --user foo --password bar --directory /tmp

        You can import the .ocs file in your inventory server with the fusioninventory-injector tool.

        The .ocs file can be imported in the following servers:
        - ocsinventory
        - GLPI using the FusionInventory for GLPI plugin
        - Uranos

        This tool is part of the FusionInventory distribution.
EOF

        exit(1);
}

sub getArray {
    my $h = shift;


    if (ref($h) eq 'ARRAY') {
        return $h;
    } else {
        return [$h];
    }
}

sub createFakeDeviceid {
    my ($hostFullInfo) = @_;

    my $hostname = $hostFullInfo->[0]{name};
    my $bootTime = $hostFullInfo->[0]{summary}{runtime}{bootTime};
    my ($year, $month, $day, $hour, $min, $sec);
    if ($bootTime =~ /(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2}):(\d{1,2})/) {
        $year = $1;
        $month = $2;
        $day = $3;
        $hour = $4;
        $min = $5;
        $sec = $6;
    } else {
        my $ty;
        my $tm;
        ($ty, $tm, $day, $hour, $min, $sec) = (localtime
                (time))[5,4,3,2,1,0];
        $year = $ty + 1900;
        $month = $tm + 1;
    }
    my $deviceid =sprintf "%s-%02d-%02d-%02d-%02d-%02d-%02d",
       $hostname, $year, $month, $day, $hour, $min, $sec;

    return $deviceid;
}

sub createEsxInventory {
    my ($args) = @_;


    my $logger = FusionInventory::Logger->new();
    my $config = FusionInventory::Agent::Config::load();


    my $url = 'http://'.$args->{host}.'/sdk/vimService';

    my $vpbs = VMware::PoorBoySOAP->new({ url => $url });
    if (!$vpbs->login($args->{user}, $args->{password})) {
        die "failed to log in\n";
    }



#my $hostInfo = $vpbs->getHostInfo();

    my $hostFullInfo = $vpbs->getHostFullInfo();

    my $inventory = FusionInventory::Agent::XML::Query::Inventory->new({
            logger => $logger,
            config => $config,
            target => { deviceid => createFakeDeviceid($hostFullInfo), path => '/tmp', vardir => '/tmp/toto' }
            });

    $inventory->{isInitialised}=1;
    $inventory->{h}{CONTENT}{HARDWARE}{ARCHNAME}=['remote'];




    $inventory->setBios({
            BDATE => $hostFullInfo->[0]{hardware}{biosInfo}{releaseDate},
            BVERSION => $hostFullInfo->[0]{hardware}{biosInfo}{biosVersion},
            SMODEL => $hostFullInfo->[0]{hardware}{systemInfo}{model},
            SMANUFACTURER => $hostFullInfo->[0]{hardware}{systemInfo}{vendor},
            ASSETTAG => $hostFullInfo->[0]{hardware}{systemInfo}{otherIdentifyingInfo}{identifierValue},
            });

    $inventory->setHardware({
            NAME => $hostFullInfo->[0]{config}{network}{dnsConfig}{hostName},
            DNS => $hostFullInfo->[0]{config}{network}{dnsConfig}{address},
            WORKGROUP => $hostFullInfo->[0]{config}{network}{dnsConfig}{domainName},
            MEMORY => int($hostFullInfo->[0]{hardware}{memorySize} / (1024*1024)),
            UUID => $hostFullInfo->[0]{summary}{hardware}{uuid} || $hostFullInfo->[0]{hardware}{systemInfo}{uuid},
#    VMSYSTEM => "VMware",
            OSVERSION => $hostFullInfo->[0]{summary}{config}{product}{version},
            OSNAME => $hostFullInfo->[0]{summary}{config}{product}{name},
            OSCOMMENTS => $hostFullInfo->[0]{summary}{config}{product}{fullName},
            });

    my %cpuManufacturor = (
            amd => 'AMD',
            intel => 'Intel',
            );
    foreach (@{getArray($hostFullInfo->[0]{hardware}{cpuPkg})}) {
        my $thread;
        my $core;


        $inventory->addCPU({
                CORE => $hostFullInfo->[0]{hardware}{cpuInfo}{numCpuCores},
                MANUFACTURER =>  $cpuManufacturor{$_->{vendor}} || $_->{vendor},
                NAME => $_->{description},
                SPEED => int($_->{hz}/(1000*1000)),
                THREAD => eval{$hostFullInfo->[0]{hardware}{cpuInfo}{numCpuThreads} / $hostFullInfo->[0]{hardware}{cpuInfo}{numCpuCores}}
                });
    }
    delete($hostFullInfo->[0]{hardware}{cpuPkg});
    my %ipaddr;
    foreach (@{$hostFullInfo->[0]{hardware}{pciDevice}}) {
        $ipaddr{$_->{ip}{ipAddress}}=1 if $_->{ip}{ipAddress};

        my $pciclass = sprintf("%x", $_->{classId});
        $inventory->addController({
                NAME => $_->{deviceName},
                MANUFACTURER => $_->{vendorName},
                PCICLASS => $pciclass,
                PCIID => sprintf("%x:%x", $_->{vendorId}, $_->{deviceId}),
                PCISUBSYSTEMID => sprintf("%x:%x", $_->{subVendorId}, $_->{subDeviceId}),
                PCISLOT => $_->{id},
                });

        if ($pciclass && ($pciclass eq '300')) {
            $inventory->addVideo({
                    NAME => $_->{deviceName},
                    PCISLOT => $_->{id},
                    }) 
        }
    }

    foreach (@{getArray($hostFullInfo->[0]{config}{network}{pnic})}) {
        $ipaddr{$_->{ip}{ipAddress}}=1 if $_->{ip}{ipAddress};
        $inventory->addNetwork({
                DESCRIPTION => $_->{device},
                DRIVER => $_->{driver},
                IPADDRESS => $_->{ip}{ipAddress},
#            IPGATEWAY => '',
                IPMASK => $_->{ip}{subnetMask},
#            IPSUBNET => '',
                MACADDR => $_->{mac},
#            MTU => '',
                PCISLOT => $_->{pci},
                STATUS => $_->{ip}{ipAddress}?'Up':'Down',
#            TYPE => '',
#            VIRTUALDEV => '',
#            SLAVES => '',
#            MANAGEMENT => '',
                SPEED => $_->{spec}{linkSpeed}{speedMb},
                });
    }

    foreach (@{getArray($hostFullInfo->[0]{config}{network}{vnic})}) {
        $ipaddr{$_->{ip}{ipAddress}}=1 if $_->{ip}{ipAddress};
        $inventory->addNetwork({
                DESCRIPTION => $_->{device},
                DRIVER => $_->{driver},
                IPADDRESS => $_->{ip}{ipAddress},
#            IPGATEWAY => '',
                IPMASK => $_->{ip}{subnetMask},
#            IPSUBNET => '',
                MACADDR => $_->{mac},
#            MTU => '',
                PCISLOT => $_->{pci},
                STATUS => $_->{ip}{ipAddress}?'Up':'Down',
#            TYPE => '',
                VIRTUALDEV => '1',
#            SLAVES => '',
#            MANAGEMENT => '',
                SPEED => $_->{spec}{linkSpeed}{speedMb},
                });
    }

    foreach ($hostFullInfo->[0]{config}{network}{consoleVnic}, $hostFullInfo->[0]{config}{vmotion}{netConfig}{candidateVnic}) {
        next if ref($_) ne 'HASH';
        $ipaddr{$_->{spec}{ip}{ipAddress}}=1 if $_->{spec}{ip}{ipAddress};

        $inventory->addNetwork({
                DESCRIPTION => $_->{device},
                IPADDRESS => $_->{spec}{ip}{ipAddress},
                IPMASK => $_->{spec}{ip}{subnetMask},
                MACADDR => $_->{spec}{mac},
                MTU => $_->{spec}{ip}{mtu},
                STATUS => $_->{spec}{ip}{ipAddress}?'Up':'Down',
                VIRTUALDEV => '1',
                });
    }

    $inventory->setHardware({IPADDR => join '/', (keys %ipaddr)});



    foreach (@{$hostFullInfo->[0]{config}{fileSystemVolume}{mountInfo}}) {

    }

    my %volumnMapping;
    foreach my $entry (@{getArray($hostFullInfo->[0]{config}{storageDevice}{scsiLun})}) {
        my $serialnumber;
        my $size;


        $volumnMapping{$entry->{canonicalName}} = $entry->{deviceName};


        foreach my $altName (@{getArray($entry->{alternateName})}) {
            next unless ref($altName) eq 'HASH';
            next unless $altName->{namespace};
            next unless $altName->{data};
            if ($altName->{namespace} eq 'SERIALNUM') {
                $serialnumber .= $_ foreach (@{$altName->{data}});
            }
        }
        if ($entry->{capacity}{blockSize} && $entry->{capacity}{block}) {
            $size = int($entry->{capacity}{blockSize} *$entry->{capacity}{block})/1000;
        }
        $inventory->addStorage({
                DESCRIPTION => $entry->{displayName},
                DISKSIZE => $size,
#        INTERFACE
                MANUFACTURER => getCanonicalManufacturer($entry->{model}) || $entry->{vendor},
                MODEL => $entry->{model},
                NAME => $entry->{deviceName},
                TYPE => $entry->{deviceType},
                SERIAL => $serialnumber,
                FIRMWARE => $entry->{revision},
#        SCSI_COID
#        SCSI_CHID
#        SCSI_UNID
#        SCSI_LUN
                });

    }

    foreach (@{getArray($hostFullInfo->[0]{config}{fileSystemVolume}{mountInfo})}) {
        my $volumn;
        if ($_->{volume}{type} && ($_->{volume}{type} =~ /NFS/i)) {
            $volumn = $_->{volume}{remoteHost}.':'.$_->{volume}{remotePath};
        } else {
            $volumn = $volumnMapping{$_->{volume}{extent}{diskName}}." ".$_->{volume}{extent}{partition};
        }
        $inventory->addDrive({
                SERIAL => $_->{volume}{uuid},
                TOTAL => int (($_->{volume}{capacity} || 0) / (1000*1000)),
                TYPE => $_->{mountInfo}{path},
                VOLUMN => $volumn,
                NAME => $_->{volume}{name},
                FILESYSTEM => lc($_->{volume}{type})
                });
    }


    my $machineIdList = $vpbs->getVirtualMachineList();
    foreach my $id (@$machineIdList) {
        my $machine = $vpbs->getVirtualMachineById($id);

        my $status;
        if ($machine->[0]{summary}{runtime}{powerState} eq 'poweredOn') {
                $status = 'running';
        }

        if (!$status) {
            print Dumper($machine->[0]);
        }

        $inventory->addVirtualMachine({
                VMID => $machine->[0]{summary}{vm},
                NAME => $machine->[0]{name},
                STATUS => $status,
                UUID => $machine->[0]{summary}{config}{uuid},
                MEMORY => $machine->[0]{summary}{config}{memorySizeMB},
                VMTYPE => 'VMware',
                VCPU => $machine->[0]{summary}{config}{numCpu},

                });

    }

    return $inventory;

}

my $inventory = createEsxInventory($args);
$inventory->writeXML();
